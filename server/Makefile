# Autogenerate the lists of source files, files to build, and dependency files
# (see below) based on the list of .erl files in this directory.
SOURCES = $(wildcard *.erl)
TARGETS = $(SOURCES:.erl=.beam)
DEPENDS = $(SOURCES:%.erl=.dependencies/%.depend)

DEPEND_DIR = .dependencies

# Default rule: build everything necessary to run the server.
all: $(TARGETS)

# Remove everything generated by make.
clean:
	rm -f $(TARGETS)
	rm -f $(DEPENDS)
	rmdir $(DEPEND_DIR)

# Instead of requiring the user to call `make depend` or anything like that,
# maintain a directory with a dependency file for each .erl file. The
# dependency files can be auto-generated using `erlc -M` (similar to
# `gcc -MM`). Each time we build a .beam file, we update the dependency file
# for the next iteration. Because we can't change the set of dependencies for
# a file without modifying at least one of its current dependencies, this
# will guarantee that we build each .beam file when we need to.
# 
# The dependency directory must exist before we can do this (otherwise `erlc
# -M` will fail). However, its modification time will be updated every time we
# access one of its files. We could make it an ordinary prerequisite and simply
# `mkdir -p` it every time we compile a file, but make gives us a nicer way to
# handle this: make the directory an "order-only prerequisite" (see
# http://www.gnu.org/software/make/manual/make.html#Prerequisite-Types
# ).
%.beam: %.erl | $(DEPEND_DIR)
	erlc -MF $(DEPEND_DIR)/$*.depend $<
	erlc $<

# As mentioned above, 
$(DEPEND_DIR):
	mkdir -p $@

.phony: all clean

# Include the generated dependencies from the previous iteration. So that we
# don't fail on the first iteration, just ignore any files that don't exist
# (hence `-include` instead of `include`).
-include $(DEPENDS)

